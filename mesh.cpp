// SPDX-FileCopyrightText: 2024 Dr. Dominik Mokris <dominik.mokris42@gmail.com>
// SPDX-License-Identifier: MIT

#ifndef MESH_CPP_GUARD
#define MESH_CPP_GUARD

#include "triangle_wm.h"
#include "mesh.h"

/*
=================================
PRIVATE:
=================================
*/

void mesh::clear_mesh()
{ 
  /* Clears the mesh by disposing all vertices and triangles. */
  point_vector.clear();
  triangle_vector.clear();
}

void mesh::insert_point( double x_coordinate, double y_coordinate, int new_boundary_marker = 0 )
{
  /* Inserts a point given by its coordinates into the mesh. */
  point Point( x_coordinate, y_coordinate, 1, new_boundary_marker );
  point_vector.push_back( Point );
}

void mesh::insert_point( point new_point )
{
  /* Inserts a given point into the mesh. */
  point_vector.push_back( new_point );
}

void mesh::insert_triangle( int index_1, int index_2, int index_3 )
{
  /* Inserts a triangle into the mesh. The vertices are given by indices into the point_vector. */
  triangle_wm Triangle( index_1, index_2, index_3, this );
  triangle_vector.push_back( Triangle );
}

/* ============================== */

void mesh::get_points_from_node( std::string node_file_name )
{
  /* Technical function reading points from node_file_name.node and putting them into the mesh. */
  node_file_name += ".node";
  std::ifstream nodin;
  try
  {
    nodin.open( node_file_name.c_str() );
    if( !nodin.good() )
    {
      file_not_open_exception e;
      throw e;
    }
    
    int nr_of_new_points;
    int actually_read_int;
  
    double new_x;
    double new_y;
    double new_boundary_marker;
  
    // The head of the node file consists of four numbers:
    // [1] Total number of the points.
    // [2] Dimension of the problem.
    // [3] 
    // [4]
    nodin >> nr_of_new_points;
    nodin >> actually_read_int;
    if( actually_read_int != 2 )
    {
      wrong_dimension_exception e;
      throw e;
    }
    
    nodin >> actually_read_int;
    nodin >> actually_read_int;
  
    for( int i = 0; i < nr_of_new_points; i++ )
    {
      nodin >> actually_read_int >> new_x >> new_y >> new_boundary_marker;
      insert_point( new_x, new_y, new_boundary_marker );
    }
    nodin.close();
  }
  catch( std::exception& e )
  {
    std::cerr << "in get_points_from_node( " << node_file_name << " ) : " << e.what() << std::endl;
    throw e;
  }
}

void mesh::get_triangles_from_ele( std::string ele_file_name )
{
  /* Similar function but reading triangles from ele_file_name.ele and then putting them into the mesh. */
  try
  {
    ele_file_name += ".ele";
    std::ifstream elin;
    elin.open( ele_file_name.c_str() );
    if( !elin.good() )
    {
      file_not_open_exception e;
      throw e;
    }
    
    triangle_vector.clear();

    int nr_of_triangles;
    int dummy_information;
    int current_line_nr;
    int new_vert1;
    int new_vert2;
    int new_vert3;

    // First, read the initial line.
    elin >> nr_of_triangles >> dummy_information >> dummy_information;
    if( nr_of_triangles < 0 )
    {
      wrong_argument_exception e;
      throw e;
    }

    // Then read the rest of the file.
    for( int i = 0; i < nr_of_triangles; i++ )
    {
      elin >> current_line_nr;
      if( current_line_nr != i )
      {
	wrong_line_number_exception e;
	throw e;
      }
      else
      {
	// If on the correct line, add this vertex.
	elin >> new_vert1 >> new_vert2 >> new_vert3;
	insert_triangle( new_vert1, new_vert2, new_vert3 );
      }
    }
    
    // Finally, close the ele file.
    elin.close();
  }
  catch( std::exception& e )
  {
    std::cerr << "in get_triangles_from_ele( " << ele_file_name << " ) : " << e.what() << std::endl;
    throw e;
  }
}

/* ========================================= */



void mesh::compute_star_triangles_centroids()
{
  /* Assigns each point its star (union of triangles for which it is a vertex). */
  // point centroid;
  for( std::vector< triangle_wm >::iterator it = triangle_vector.begin(); it != triangle_vector.end(); ++it )
  {
    // centroid = it -> get_whole_centroid();
    point* centroid_pt = new point( it -> get_centroid_x(), it -> get_centroid_y(), it -> compute_area(), 0 );
    // centroid_pt -> change_coordinates( centroid.get_x(), centroid.get_y() );
    
    ( point_vector[ it -> get_vertex_1() ] ).add_star_corner( centroid_pt );
    ( point_vector[ it -> get_vertex_2() ] ).add_star_corner( centroid_pt );
    ( point_vector[ it -> get_vertex_3() ] ).add_star_corner( centroid_pt );
  }
}


void mesh::compute_voronoi_cells_corners()
{
  /* Each vertex is assigned corners of the Voronoi region generated by it, i.e. the circumcentra of adjacent vertices. */
  // Auxiliary variables
  int vertex_1_index;
  int vertex_2_index;
  int vertex_3_index;
  double new_x;
  double new_y;
  point circumcenter;
    
  // Come through all the triangles in the triangulation
  for( std::vector< triangle_wm >::iterator it = triangle_vector.begin(); it != triangle_vector.end(); ++ it )
  {
    // See, which points are in the triangle.
    vertex_1_index = it -> get_vertex_1();
    vertex_2_index = it -> get_vertex_2();
    vertex_3_index = it -> get_vertex_3();
    
    // Make its circumcenter
    circumcenter = it -> compute_circumcenter();
    new_x = circumcenter.get_x();
    new_y = circumcenter.get_y();
    
    // Make a pointer for it.
    point* new_corner = new point( new_x, new_y, 1, 0 );
    
    // This centroid is a Voronoi cell corner to all vertices
    point_vector[ vertex_1_index ].add_voronoi_corner( new_corner );
    point_vector[ vertex_2_index ].add_voronoi_corner( new_corner );
    point_vector[ vertex_3_index ].add_voronoi_corner( new_corner );
    
    it -> check_the_boundary();
  }
}


/* ====================================== */

void mesh::write_to_file_mph( std::string filename )
{
  /* Writes the information about mesh into filename.mphtxt, suitable for usage in COMSOL Multiphysics program suite. */
  filename += ".mphtxt";
  std::ofstream fout;
  fout.open( filename.c_str() );
  
  fout << "# Major & minor version\n";
  fout << "0 1\n1 # number of tags\n";
  fout << "# Tags\n6 fem1.0\n";
  fout << "1 # number of types\n";
  fout << "# Types\n3 obj\n\n";
  fout << "# --------- Object 0 ----------\n\n";
  fout << "0 0 1\n";  
  fout << "4 Mesh # class\n";
  fout << "1 # version\n2 # sdim \n";
  fout << point_vector.size() << " # number of mesh points\n";
  fout << "0 # lowest mesh point index\n# Mesh point coordinates on unit square\n";
  
  for( std::vector< point >::iterator it = point_vector.begin(); it != point_vector.end(); ++it)
    (*it).point::write_mph( fout );
  
  fout << "1 # number of element types\n";
  fout << "3 tri # type name\n";
  fout << "3 # number of nodes per element\n";
  fout << triangle_vector.size() << " # number of elements\n";
  fout << "# Triangular elements\n";
  
  for( std::vector< triangle_wm >::iterator it = triangle_vector.begin(); it != triangle_vector.end(); ++it)
    it->triangle_wm::write( fout );
  
  fout << "6 # number of parameter values per element\n";
  fout << "0 # number of parameters\n";
  fout << "4 # number of domains\n";
  fout << "# Domains\n";
  
  for( int i = 0; i < triangle_vector.size(); i++)
    fout << "1\n";
  
  fout << "0 # number of up/down pairs";
  
  fout.close();
}

void mesh::write_to_file_node( std::string filename )
{
  /* Writes the mesh into filename.node and filename.ele, together suitable for treatment in Triangle or Showme. */
  
  // First, write the vertices into a node file.
  // Specification of the node files is available at http://www.cs.cmu.edu/~quake/triangle.node.html
  std::string node_file_name = filename + ".node";
  std::ofstream fout;
  fout.open( node_file_name.c_str() );
  
  fout << point_vector.size() << " 2 0 0" << std::endl;
  int i = 0;  
  for( std::vector< point >::iterator it = point_vector.begin(); it != point_vector.end(); ++it, i++ )
  {
    fout << i << " ";
    (*it).write_node( fout );
  }
  fout.close();
  
  // Second, write the triangles into an ele file.
  // Specification of the ele files is available at http://www.cs.cmu.edu/~quake/triangle.ele.html
  
  std::string ele_file_name = filename + ".ele";
  fout.open( ele_file_name.c_str() );
  fout << triangle_vector.size() << " " << "3 0" << std::endl;
  // nr of triangles, nr of vertices per element (triangles here, so three) and nr of additional attributes
  for( int i = 0; i < triangle_vector.size(); i++ )
  {
    fout << i << " ";
    triangle_vector[ i ].write( fout );
  }
  
  fout.close();
}


/*
===========================================
PUBLIC:
===========================================
*/

void mesh::read_whole_mesh_from_node_and_ele( std::string file_name )
{
  /* Having files filename.node and file_name.ele it updates the mesh parts: the triangle_vector and the point_vector. */
  clear_mesh();
  try
  {
    get_points_from_node( file_name );
    get_triangles_from_ele( file_name );
  }
  catch( std::exception& e )
  {
    std::cerr << "in read_whole_mesh_from_node_and_ele( " << file_name << " ) : " << e.what() << std::endl;
    throw e;
  }
}


void mesh::CVT_balance()
{
  /* The reason why we are still working on this programme is this function.
  It is a version of the Lloyd's algorithm to computing Centroidal Voronoi Tessellations.
  
  For a comprehensive treatment, see e.g.
  Q. Du, V. Faber and M. Gunzburger: Centroidal Voronoi Tessellations: Applications and Algorithms,
  SIAM Review 1999, pp. 637--676.
  Also available in a pdf at https://trac.csse.rose-hulman.edu/LIDCOM/export/4/ProgressiveMesh/CentroidalTessellations.pdf
  
  Other articles may be found, e.g. by Lili Ju or J. Burns. */
  
  /* The principle in brief:
  We have a region in R^2 (a circle in our case) and we want to put points inside so that if we make their Voronoi diagram, then each of
  them is a circumcenter of its Voronoi region.
  Classical Lloyd's algorithm suggests to make an initial tessellation, then put each point into the circumcenter of its region and iterate
  this way until some stopping criteria are met.
  However, in our case, we are implementing an innovation. Instead of computing Voronoi regions, we make the Delauney triangulation
  (a dual to Voronoi diagram) and from it we make the balancing. It eases checking, if the triangulation is already good enough
  and also makes place for further improvements: I would like the mesh to improve not the whole at the same time but in every step to
  improve the point that is further from its circumcenter (and store them e.g. in a heap). The Delauney triangulation is easy to update if
  it has been changed only locally via the flipping algorithm.
  But this is not implemented yet. Triangle uses Divide--and--Conquer method instead of edge flipping. */
  try
  {
    compute_voronoi_cells_corners();
    
    for( std::vector< point >::iterator it = point_vector.begin(); it != point_vector.end(); ++ it )
      if( it -> get_boundary_marker() == 0 )
	it -> move_to_voronoi_cell_centroid( problem_pt );
  }
  catch( std::exception& e )
  {
    std::cerr << "in mesh::CVT_balance() : " << e.what() << std::endl;
    throw e;
  }
}

void mesh::ODT_balance()
{
  /* A different approach,
  see e.g. L.Chen: Optimal Delaunay Triangulations, Computin (2007).
  Each interior point is moved into the centroid of its star (union of adjacent triangles), converging to Optimal Delaunay
  triangulation (ODT), minimizing the interpolation error among all triangulations of the given domain having the same number
  of vertices under some restrictions, see the paper. */
  try
  {
    compute_star_triangles_centroids();
  
    for( std::vector< point >::iterator it = point_vector.begin(); it != point_vector.end(); ++it )
      if( it -> get_boundary_marker() == 0 )
	it -> move_to_star_centroid( problem_pt );
  }
  catch( std::exception& e )
  {
    std::cerr << "in mesh::ODT_balance() : " << e.what() << std::endl;
    throw e;
  }
}


void mesh::write_to_file( std::string filename, std::string extension )
{
  /* Disambiguation of how to write the file according to a specified file format. */
  if( extension == "mph" ) // Tim mph myslim mphtxt, ma to jeste binarkovou verzi.
    write_to_file_mph( filename );
  
  else if( extension == "node" )
    write_to_file_node( filename );
  
  else
  {
    unknown_file_format_exception e;
    std::cerr << "in mesh::write_to_file( " << filename << ", " << extension << " ) : " << std::endl;
    throw e;
  }
}

void mesh::angle_statistics()
{
  /* Counts occurences of each angle size in the whole mesh and writes it into a file. */
  
  std::vector< int > angle_occurences;
  angle_occurences.assign( 181, 0 );
  
  for( std::vector< triangle_wm >::iterator it = triangle_vector.begin(); it != triangle_vector.end(); ++it )
    (*it).add_angles_to_vector( angle_occurences );
  
  std::ofstream fout;
  std::string filename = "angle_statistics.txt";
  fout.open( filename.c_str() );
  
  //int i = 0;
  for( std::vector< int >::iterator it = angle_occurences.begin(); it != angle_occurences.end(); ++it )
    fout << (*it) << std::endl;
  
  fout.close();
}


point& mesh::get_point_from_vector( int point_index )
{
  /* Transition from point to a vector, technical function. */
  return point_vector[ point_index ];
}


int mesh::get_smallest_angle()
{
  /* Counts the smallest angle in the triangulation (in degrees). */
  std::vector< int > angle_occurences;
  angle_occurences.assign( 181, 0 ); // At least one of the angles is less or equal to 60 degrees because of the Dirichlet (pigeonhole) principle.
  
  for( std::vector< triangle_wm >::iterator it = triangle_vector.begin(); it != triangle_vector.end(); ++it )
    (*it).add_angles_to_vector( angle_occurences );
  
  int i = 0;
  for( std::vector< int >::iterator it = angle_occurences.begin(); it != angle_occurences.end(); ++it, i++ )
    if( *it != 0 )
      return i;
}



void mesh::create_domain( char option, int nr_boundary_vertices )
{
  /* Prepares a domain for further treatment. */
  try
  {
    clear_mesh();
    problem_pt -> update_domain_option( option );
    problem_pt -> create_domain_boundary( nr_boundary_vertices );
  }
  catch( std::exception& e )
  {
    std::cerr << "in create_domain( " << option << " , " << nr_boundary_vertices << " ) : " << e.what() << std::endl;
    throw e;
  }
}

void mesh::refine( int nr_new_vertices )
{
  /* Adding vertices inside the domain. */
  try
  {
    problem_pt -> refine( nr_new_vertices );
  }
  catch( std::exception& e )
  {
    std::cerr << "in refine( " << nr_new_vertices << " ) : " << e.what() << std::endl;
  }
}

mesh::mesh()
{
  /* Sorry for inducing exception able things in the constructor, I know, it's not good. However, it seems to work and we need the problem
to be ready for the mesh. */
  problem_pt = new problem( this );
}
      
#endif //MESH_CPP_GUARD
